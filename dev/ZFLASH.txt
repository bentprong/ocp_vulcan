#ifdef __cplusplus
extern "C"
{
#endif

#include <stdint-gcc.h>
#include <Arduino.h>
#include <FlashAsEEPROM_SAMD.h>

typedef struct {
 uint16_t         pageSize;
 uint32_t         pageCount;
 uint16_t         rowSize;
 uint16_t         EEPROMPages;

} FLASH_DvcCtrl_t;

typedef struct {
    uint32_t        sig;
    float           K;
} EEPROM_data_t;

// FLASH/EEPROM Device Control Block
static FLASH_DvcCtrl_t  FLASH_DCB;
static const uint32_t   EEPROM_signature = 0xDEADBEEF;
static EEPROM_data_t    EEPROMData;
static const uint16_t   pageSizes[] = { 8, 16, 32, 64, 128, 256, 512, 1024 };

uint32_t readUnaligned32Bits(void *data)
{
    union {
        uint32_t    u32;
        uint8_t     u8[4];
    } res;

    uint8_t         *d = (uint8_t *) data;

    res.u8[0] = d[0];
    res.u8[1] = d[1];
    res.u8[2] = d[2];
    res.u8[3] = d[3];
    return(res.u32);
}

void FLASH_ReadySync(void)
{
    while (NVMCTRL->INTFLAG.bit.READY == 0 ) {};
}

#ifdef __cplusplus
}
#endif

bool ZFLASH_Init(void)
{
    uint16_t        pageSizeField;
    uint32_t        pageCount;
    bool            rc = true;
    uint32_t        temp;
    uint8_t         *p = (uint8_t *) &EEPROMData;
    uint16_t        eepromAddr = 0;

    pageSizeField = NVMCTRL->PARAM.bit.PSZ;
    FLASH_DCB.pageSize = pageSizes[pageSizeField];
    FLASH_DCB.pageCount = NVMCTRL->PARAM.bit.NVMP;
    FLASH_DCB.rowSize = FLASH_DCB.pageSize * 4;

    for ( int i = 0; i < sizeof(EEPROM_data_t); i++ )
    {
        *p++ = EEPROM.read(eepromAddr++);
    }

    return(rc);
}

#if 0
void FLASH_Read(const volatile void *flashAddress, void *data, uint32_t length)
{
    memcpy(data, (const void*) flashAddress, length);
}

void FLASH_Write(const volatile void *flashAddress, void *data, uint32_t length)
{
  volatile uint32_t     *dst_addr = (volatile uint32_t *) flashAddress;
  const uint8_t         *src_addr = (uint8_t *)data;

  // Calculate data boundaries
  length = (length + 3) / 4;

  // Disable automatic page write
  NVMCTRL->CTRLB.bit.MANW = 1;

  while ( length )
  {
    NVMCTRL->CTRLA.reg = NVMCTRL_CTRLA_CMDEX_KEY | NVMCTRL_CTRLA_CMD_PBC;
    FLASH_ReadySync();

    uint32_t            i;

    // file page buffer
    for ( i = 0; i <(FLASH_DCB.pageSize/4) && length; i++ )
    {
        *dst_addr++ = readUnaligned32Bits(src_addr);
        src_addr += 4;
        length--;
    }

    // execute Write Page
    NVMCTRL->CTRLA.reg = NVMCTRL_CTRLA_CMDEX_KEY | NVMCTRL_CTRLA_CMD_WP;
    FLASH_ReadySync();
  }
}

static void _erase(const volatile void *flashAddress)
{
    NVMCTRL->ADDR.reg = ((uint32_t) flashAddress) / 2;
    NVMCTRL->CTRLA.reg = NVMCTRL_CTRLA_CMDEX_KEY | NVMCTRL_CTRLA_CMD_ER;
    FLASH_ReadySync();
}

void FLASH_Erase(const volatile void *flashAddress, uint32_t length)
{
    const uint8_t *ptr = (const uint8_t *) flashAddress;

    while ( length > FLASH_DCB.rowSize )
    {
        _erase(ptr);
        ptr += FLASH_DCB.rowSize;
        length -= FLASH_DCB.rowSize;
    }
}
#endif // 0 


